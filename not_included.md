# Графика
## Палитра

Если вы использеуте меньше цветов в палитре чем 16, то необязательно добавлять все цвета в массив public static short[] palette, можно просто написать 
```java
  public static short[] palette =
  {
    0xeee, 0x0,
  };
```

# Музыка

У Yamaha YM2612 дополнительно есть 2 режима: LFO(Low-frequency oscillation), DAC(Digital to Analog Converter). первый используется 


Максимальный размер звука который вы можете загрузить в Z80 это 8 Кб(написать точное значение в байтах) минус несколько байт на код воспроизведения и того получается чуть меньше 8 Кб, этого конечно же недостаточно для полноценной музыки. Есть 3 способа как воспроизвести звук: DAC(Digital to Analog Converter), Yamaha 2612, PSG(Programmable Sound Generator). Мы будем использовать DAC, так как PSG в основном используется для белого шума, а как загрузить музыку в Yamaha 2612 я так и не разобрался. Для того чтобы загрузить музыку которая больше 8Кб нам нужно будет загружать ее частично в Z80 и подать в него в оффсет … абсолютный адрес начала данных музыки в роме(Данный метод был взят из движка GINCS с которым я работал до этого). Для этого нам нужно сначала загрузить музыку в ром, потом найти абсолютный адрес начала музыки в роме и после записать код в Z80 с помощью функции loadZ80(byte[] code) с адресом вставленным в оффсет …
Для того чтобы записать данные музыки в ром нам сначала нужно подготовить файл который будет звучать в нашей игре. Файл должен быть в формате .wav(с другими не экспериментировал, скорей всего тоже получиться), с частотой 8-bit, в моно формате, с   определенным количеством герц, герцы подбирать не обязательно, это нужно для того что бы музыка звучала одинаково как на компьютере, так и на железе. После того как подготовили файл нужно вытащить из него данные в raw формате, для этого можете воспользоваться скриптом или найти другой способ. Далее эти данные нужно преобразовать в Java массив byte[], он отличается от массива байт на других языках. Значение массива byte должно быть от 0 до -1, причем если значение будет больше 127, то значение байт будет -128, также не желательно писать байты в 16-ричном формате, так как в Java тип hex значений числа после 0x79 будут int, и нужно будет приводить каждое значение к типу byte.

При использовании GINCS проигрывателя, записать адрес в оффсет в обратном порядке 0x3A-0x3C и длину в оффсет 0x3D-0x3F в z80 RAM

# Код

Минимальная программа hello world выглядет вот так

```java
import net.mikekohn.java_grinder.SegaGenesis;

public class Main
{  
  static public void main(String[] args)
  {                                              
    // Set Font.
    SegaGenesis.loadFonts();
    SegaGenesis.setPaletteColors(palette);

    SegaGenesis.setCursor(128, 128);
    SegaGenesis.print("HELLO WORLD");  
  }
  
  public static short[] palette =
  {
    0xeee, 0x0,
  };
} 
```

если поместить palette в функцию main то скомпилированный файл будет весить больше с 06C1 в 06E9
